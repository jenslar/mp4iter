use binrw::BinRead;

#[derive(Debug, BinRead)]
#[br(import {size: u32})]
pub struct Audio {
    pub(crate) version: u16,
    /// A 16-bit integer.
    pub(crate) revision_level: u16,
    /// A 32-bit integer that specifies the developer of the compressor that generated the compressed data.
    pub(crate) vendor: u32,
    #[br(args {size, version})]
    pub(crate) audio_version: AudioVersion,
}

impl Audio {
    pub fn revision_level(&self) -> u16 {
        self.revision_level
    }

    pub fn vendor(&self) -> u32 {
        self.vendor
    }

    pub fn audio_version(&self) -> &AudioVersion {
        &self.audio_version
    }

    pub fn audio_channels(&self) -> i32 {
        match &self.audio_version {
            AudioVersion::Version0(v0) => v0.number_of_channels as i32,
            AudioVersion::Version1(v1) => v1.number_of_channels as i32,
            AudioVersion::Version2(v2) => v2.num_audio_channels,
        }
    }

    pub fn sample_size(&self) -> Option<i16> {
        match &self.audio_version {
            AudioVersion::Version0(v0) => Some(v0.sample_size),
            AudioVersion::Version1(v1) => Some(v1.sample_size),
            _ => None, // calculate?
        }
    }

    pub fn sample_rate(&self) -> Option<f64> {
        let fixed_point = match &self.audio_version {
            AudioVersion::Version0(v0) => Some(v0.sample_rate),
            AudioVersion::Version1(v1) => Some(v1.sample_rate),
            _ => None, // calculate?
        }?;
        Some(fixed_point as f64 / 2_u32.pow(16) as f64)
    }
}

#[derive(Debug, BinRead)]
#[br(import {size: u32, version: u16})]
pub enum AudioVersion {
    #[br(pre_assert(version == 0))]
    Version0(
        #[br(args {size})]
        AudioVersion0
    ),
    #[br(pre_assert(version == 1))]
    Version1(
        #[br(args {size})]
        AudioVersion1
    ),
    #[br(pre_assert(version == 2))]
    Version2(
        #[br(args {size})]
        AudioVersion2
    ),
}

#[derive(Debug, BinRead)]
#[br(import {size: u32})]
pub struct AudioVersion0 {
    /// A 16-bit integer that indicates the number of
    /// sound channels used by the sound sample.
    pub number_of_channels: i16,
    /// A 16-bit integer that specifies the number of
    /// bits in each uncompressed sound sample.
    pub sample_size: i16,
    pub compression_id: i16,
    /// Should be set to 0.
    pub packet_size: i16,
    /// A 32-bit unsigned fixed-point number (16.16) that indicates
    /// the rate at which the sound samples were obtained.
    pub sample_rate: u32,
    /// Audio extensions as bytes (currently not parsed)
    #[br(count = size - 24 - 12)]
    pub extensions: Vec<u8>
}

#[derive(Debug, BinRead)]
#[br(import {size: u32})]
pub struct AudioVersion1 {
    /// A 16-bit integer that indicates the number of
    /// sound channels used by the sound sample.
    pub number_of_channels: i16,
    /// A 16-bit integer that specifies the number of
    /// bits in each uncompressed sound sample.
    pub sample_size: i16,
    pub compression_id: i16,
    /// Should be set to 0.
    pub packet_size: i16,
    /// A 32-bit unsigned fixed-point number (16.16) that indicates
    /// the rate at which the sound samples were obtained.
    pub sample_rate: u32,
    /// The number of uncompressed frames generated by a compressed frame,
    /// where an uncompressed frame is one sample from each channel.
    ///
    /// This is also the frame duration, expressed in the media’s timescale,
    /// where the timescale is equal to the sample rate. For uncompressed formats, this field is always 1.
    pub samples_per_packet: u32, // GUESS, type not specified, maybe u8?
    pub bytes_per_packet: u32, // GUESS, type not specified
    pub bytes_per_frame: u32, // GUESS, type not specified
    pub bytes_per_sample: u32, // GUESS, type not specified
    /// Audio extensions as bytes (currently unsupported)
    #[br(count = size - 24 - 28)]
    pub extensions: Vec<u8>
}

#[derive(Debug, BinRead)]
#[br(import {size: u32})]
pub struct AudioVersion2 {
    _always3: i16,
    _always16: i16,
    _always_minus2: i16,
    _always0: i16,
    _always65536: i32,
    /// A 32-bit integer field providing the offset to
    /// sound sample description structure’s extensions.
    _size_of_struct_only: i32,
    /// A 32-bit integer field set to the number of audio channels.
    pub num_audio_channels: i32,
    _always_7f000000: i32,
    /// A 32-bit integer field which is set only if constant
    /// and only for uncompressed audio.
    pub bits_per_channel: i32,
    /// A 32-bit integer field which carries LPCM flag values.
    pub format_specific_flags: i32,
    /// A 32-bit unsigned integer set to the number of bytes
    /// per packet only if this value is constant.
    pub bytes_per_audio_packet: u32,
    /// A 32-bit unsigned integer set to the number of
    /// PCM frames per packet only if this value is constant.
    pub pcm_frames_per_audio_packet: u32,
    /// Audio extensions as bytes (currently unsupported)
    #[br(count = size - 24 - 40)]
    pub extensions: Vec<u8>
}
